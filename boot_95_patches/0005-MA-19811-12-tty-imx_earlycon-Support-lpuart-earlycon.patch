From b45f96524e57285723d4168f8e0c0e5283d0e7b3 Mon Sep 17 00:00:00 2001
From: Jindong Yue <jindong.yue@nxp.com>
Date: Tue, 30 Nov 2021 17:08:41 +0800
Subject: [PATCH 5/5] MA-19811-12 tty: imx_earlycon: Support lpuart earlycon

Split lpuart early console driver from fsl_lpuart.c
to imx_earlycon.c

Signed-off-by: Jindong Yue <jindong.yue@nxp.com>
Change-Id: I55ec183aa6039e4666e985053caf669b78fef5b8
---
 arch/arm64/configs/gki_defconfig  |  1 +
 drivers/tty/serial/Kconfig        |  1 -
 drivers/tty/serial/fsl_lpuart.c   | 12 ------
 drivers/tty/serial/imx_earlycon.c | 68 +++++++++++++++++++++++++++++++
 4 files changed, 69 insertions(+), 13 deletions(-)

diff --git a/arch/arm64/configs/gki_defconfig b/arch/arm64/configs/gki_defconfig
index e03b63f00968..6aafdc980523 100644
--- a/arch/arm64/configs/gki_defconfig
+++ b/arch/arm64/configs/gki_defconfig
@@ -407,6 +407,7 @@ CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
 CONFIG_SERIAL_SAMSUNG=y
 CONFIG_SERIAL_SAMSUNG_CONSOLE=y
 CONFIG_SERIAL_TEGRA_TCU=y
+CONFIG_SERIAL_IMX_EARLYCON=y
 CONFIG_SERIAL_QCOM_GENI=y
 CONFIG_SERIAL_QCOM_GENI_CONSOLE=y
 CONFIG_SERIAL_SPRD=y
diff --git a/drivers/tty/serial/Kconfig b/drivers/tty/serial/Kconfig
index 87eb2835fd34..891769aecd0f 100644
--- a/drivers/tty/serial/Kconfig
+++ b/drivers/tty/serial/Kconfig
@@ -493,7 +493,6 @@ config SERIAL_IMX_CONSOLE
 
 config SERIAL_IMX_EARLYCON
 	bool "Earlycon on IMX serial port"
-	depends on ARCH_MXC || COMPILE_TEST
 	depends on OF
 	select SERIAL_CORE
 	select SERIAL_EARLYCON
diff --git a/drivers/tty/serial/fsl_lpuart.c b/drivers/tty/serial/fsl_lpuart.c
index 385b41275e8b..eb2a5cc9c25b 100644
--- a/drivers/tty/serial/fsl_lpuart.c
+++ b/drivers/tty/serial/fsl_lpuart.c
@@ -2748,18 +2748,6 @@ static int __init ls1028a_early_console_setup(struct earlycon_device *device,
 	return 0;
 }
 
-static int __init lpuart32_imx_early_console_setup(struct earlycon_device *device,
-						   const char *opt)
-{
-	if (!device->port.membase)
-		return -ENODEV;
-
-	device->port.iotype = UPIO_MEM32;
-	device->port.membase += IMX_REG_OFF;
-	device->con->write = lpuart32_early_write;
-
-	return 0;
-}
 OF_EARLYCON_DECLARE(lpuart, "fsl,vf610-lpuart", lpuart_early_console_setup);
 OF_EARLYCON_DECLARE(lpuart32, "fsl,ls1021a-lpuart", lpuart32_early_console_setup);
 OF_EARLYCON_DECLARE(lpuart32, "fsl,ls1028a-lpuart", ls1028a_early_console_setup);
diff --git a/drivers/tty/serial/imx_earlycon.c b/drivers/tty/serial/imx_earlycon.c
index 7aab38b2bd8c..45dd68460883 100644
--- a/drivers/tty/serial/imx_earlycon.c
+++ b/drivers/tty/serial/imx_earlycon.c
@@ -16,6 +16,12 @@
 #define UTS_TXFULL (1<<4) /* TxFIFO full */
 #define IMX21_UTS 0xb4 /* UART Test Register on all other i.mx*/
 
+/* IMX lpuart has four extra unused regs located at the beginning */
+#define IMX_REG_OFF	0x10
+#define UARTSTAT		0x04
+#define UARTDATA		0x0C
+#define UARTSTAT_TDRE		0x00800000
+
 static void imx_uart_console_early_putchar(struct uart_port *port, unsigned char ch)
 {
 	while (readl_relaxed(port->membase + IMX21_UTS) & UTS_TXFULL)
@@ -42,8 +48,70 @@ imx_console_early_setup(struct earlycon_device *dev, const char *opt)
 
 	return 0;
 }
+
+static inline u32 lpuart32_read(struct uart_port *port, u32 off)
+{
+	switch (port->iotype) {
+	case UPIO_MEM32:
+		return readl(port->membase + off);
+	case UPIO_MEM32BE:
+		return ioread32be(port->membase + off);
+	default:
+		return 0;
+	}
+}
+
+static void lpuart32_wait_bit_set(struct uart_port *port, unsigned int offset,
+				  u32 bit)
+{
+	while (!(lpuart32_read(port, offset) & bit))
+		cpu_relax();
+}
+
+static inline void lpuart32_write(struct uart_port *port, u32 val,
+				  u32 off)
+{
+	switch (port->iotype) {
+	case UPIO_MEM32:
+		writel(val, port->membase + off);
+		break;
+	case UPIO_MEM32BE:
+		iowrite32be(val, port->membase + off);
+		break;
+	}
+}
+
+static void lpuart32_console_putchar(struct uart_port *port, unsigned char ch)
+{
+	lpuart32_wait_bit_set(port, UARTSTAT, UARTSTAT_TDRE);
+	lpuart32_write(port, ch, UARTDATA);
+}
+
+static void lpuart32_early_write(struct console *con, const char *s, unsigned n)
+{
+	struct earlycon_device *dev = con->data;
+
+	uart_console_write(&dev->port, s, n, lpuart32_console_putchar);
+}
+
+static int __init lpuart32_imx_early_console_setup(struct earlycon_device *device,
+						   const char *opt)
+{
+	if (!device->port.membase)
+		return -ENODEV;
+
+	device->port.iotype = UPIO_MEM32;
+	device->port.membase += IMX_REG_OFF;
+	device->con->write = lpuart32_early_write;
+
+	return 0;
+}
+
 OF_EARLYCON_DECLARE(ec_imx6q, "fsl,imx6q-uart", imx_console_early_setup);
 OF_EARLYCON_DECLARE(ec_imx21, "fsl,imx21-uart", imx_console_early_setup);
+OF_EARLYCON_DECLARE(lpuart32, "fsl,imx7ulp-lpuart", lpuart32_imx_early_console_setup);
+OF_EARLYCON_DECLARE(lpuart32, "fsl,imx8qxp-lpuart", lpuart32_imx_early_console_setup);
+OF_EARLYCON_DECLARE(lpuart32, "fsl,imxrt1050-lpuart", lpuart32_imx_early_console_setup);
 
 MODULE_AUTHOR("NXP");
 MODULE_DESCRIPTION("IMX earlycon driver");
-- 
2.34.1

